; Ф.И.О., группа 2._
; Лабораторная работа №7 вариант 10
; Задание: Выводить ежесекундно в правом верхнем углу экрана системное время “часы : минуты : секунды”.

data segment        ; директива начала сегмента данных
	EXIT db 0 		    ; признак завершения программы (не 0)
	POS_H1 dw 144 	    ; позиция начального вывода часов
	POS_H2 dw 146
	POS_M1 dw 150	    ; позиция начального вывода минут
	POS_M2 dw 152
	POS_S1 dw 156	    ; позиция начального вывода секунд
	POS_S2 dw 158
	OLD_CS dw ? 	    ; адрес сегмента старого вектора 1Сh
	OLD_IP dw ? 	    ; адрес смещения старого вектора 1Сh
data ends           ; директива конца сегмента данных

code segment        ; директива начала сегмента кодов
	assume cs:code, ds:data     ; установка соответствий сегментов и их адресов 
	                            ; cs - указывает на код программы, ds - на данные
	; Основная программа
	START: 
		mov ax, data            ; сегментация данных
		mov ds, ax
		
		; чтение вектора прерывания
		mov ah, 35h
		mov al, 1Ch
		int 21h
		mov OLD_IP, bx
		mov OLD_CS, es
		
		; установка вектора прерывания
		push ds
		mov dx, offset NEW_1C
		mov ax, seg NEW_1C
		mov ds, ax
		
		mov ah, 25h
		mov al, 1Ch
		int 21h
		
		pop ds              ; сохраняем наш сегмент данных в стек
		
		mov ax, 0B800h      ; адрес сегмента буфера дисплея
		mov es, ax

		call CLS 		    ; очистка экрана
		call DELAY 		    ; стартовая задержка
		
		; цикл вывода времени на экране с определенной задержкой
		Start_out: 
			cmp EXIT, 1 		; если 1, то выходим
			je quit
			call Time_hours 	; вызов подпрограммы отображения часов
			call Time_minutes 	; вызов подпрограммы отображения минут
			call Time_seconds 	; вызов подпрограммы отображения секунд
		
			jmp Start_out 		; зацикливание
	
	; очистка экрана и завершение программы
	quit: 
		call CLS            ; очистка экрана
		mov dx, OLD_IP      ; восстановление адреса
		mov ax, OLD_CS      ; восстановление адреса
		mov ds, ax
		mov ah, 25h         ; восстанавливаем первоначальный адрес
		mov al, 1Ch
		int 21h
		mov ax, 4c00h       ; Код завершения 0
		int 21h             ; Выход в DOS
		
	; Подпрограмма обработки прерывания 1Сh
	NEW_1C proc far
		push ax 			; сохранить все регистры
		push bx
		push cx
		push dx
		push ds
		push es
		
		mov ax, data 		; установить ds на сегмент данных
		mov ds, ax 			; основной программы
		
		mov ax, 40h 		; установить es на
		mov es, ax 			; сегмент данных bios
		
		mov ax, es:[1ch]    ; пишем в регистр голову буфера клавиатуры
		mov bx, es:[1ah]    ; в другой пишем хвост буфера клавиатуры
		
		cmp bx , ax          ; если они равны, то буфер пуст
		jne Interrupt_start  ; если не равны, то переходим к метке
		
		jmp back               ; в ином случае переходим к восстановлению регистров
		
		Interrupt_start: 
		mov al, es:[bx] 	    ; заносим в al символ находящийся в голове
		mov es:[1ch], bx        ; заносим в хвост символ, находящийся в голове
		cmp al, 30h 		    ; проверка на нажатие клавиши 0
		jnz back 			
		mov EXIT, 1 		; если клавиша равна 0, то меняем значение на 1
		back: 
			pop es 			; восстановление всех регистров
			pop ds
			pop dx
			pop cx
			pop bx
			pop ax
			iret            ; возвращаемся в основную программу с восстановлением CS,IP и регистра флагов
		
	NEW_1C endp
	
	; Подпрограмма очистки экрана
	CLS proc near
		push cx                 ; сохранить все регистры
		push ax
		push si
		
		xor si, si
		mov ah, 7               ; цвет фона

		mov dl, ' '
		mov cx, 2000            ;80*25 
		;это столбцы и строки цветного видеобуффера,которые будут заполнены через цикл...
		
		CL1: 
		mov es:[si], ax         ;...нулями,собственно вот этой инструкцией
		inc si
		inc si
		loop CL1                ; повторяем все это дело 2000 раз,ибо это число байт видеобуфера
		
		pop si                  ; восстановление регистров
		pop ax
		pop cx
		ret                     ; возвращаемся в основную программу с восстановлением CS,IP
		
	CLS endp
	
	; Подпрограмма задержки
	DELAY proc near
		push cx             ; сохраняем регистр,так как его старое значение еще понадобится
		mov cx, 18          ; в секунде 18,2 тика => задержка на 18 тиков
		pop cx              ; восстанавливаем регистр
		ret                 ; возвращаемся в основную программу с восстановлением CS,IP
		
	DELAY endp
	
	; Подпрограммы вывода времени
	Time_hours proc near
		push ax         ; сохраняем регистры
		push bx
		push cx
		
		mov ah,02h		; читать время из "постоянных" (CMOS) часов реального времени
		int 1Ah
		mov al,ch		; час в формате BCD
		ror ax,1		; циклический сдвиг вправо на 4 бита
		ror ax,1
		ror ax,1
		ror ax,1
		shr ah,1		; логический сдвиг вправо на 4 бита
		shr ah,1
		shr ah,1
		shr ah,1
		or ax,'00'      ; в общем эта конструкция(156-164) выполняет корректировку полученного ASCII-кода часов
		
		mov bx, POS_H1 	; указываем позицию
		call DELAY 		; производим задержку
		mov es:[bx], al ; производим отображение на позиции символа 
		
		mov bx, POS_H2 	; указываем позицию
		call DELAY 		; производим задержку
		mov es:[bx], ah ; производим отображение на позиции символа		
		
		pop cx          ; восстанавливаем регистры
		pop bx
		pop ax  
		ret             ; возвращаемся в основную программу с восстановлением CS,IP
	Time_hours endp
	
	Time_minutes proc near
		push ax         ; сохраняем регистры
		push bx
		push cx
		
		mov ah,02h		; читать время из "постоянных" (CMOS) часов реального времени
		int 1Ah
		mov al,cl		; минуты в формате BCD
		ror ax,1		; циклический сдвиг вправо на 4 бита
		ror ax,1
		ror ax,1
		ror ax,1
		shr ah,1		; логический сдвиг вправо на 4 бита
		shr ah,1
		shr ah,1
		shr ah,1
		or ax,'00'      ; в общем эта конструкция(188-196) выполняет корректировку полученного ASCII-кода минут
		
		mov bx, POS_M1 	; указываем позицию
		call DELAY 		; производим задержку
		mov es:[bx], al ; производим отображение на позиции символа 
		
		mov bx, POS_M2 	; указываем позицию
		call DELAY 		; производим задержку
		mov es:[bx], ah ; производим отображение на позиции символа
		
		pop cx          ; восстанавливаем регистры
		pop bx
		pop ax
		ret             ; возвращаемся в основную программу с восстановлением CS,IP
	Time_minutes endp
	
	Time_seconds proc near
		push ax         ; сохраняем регистры
		push bx
		push dx
		
		mov ah,02h		; читать время из "постоянных" (CMOS) часов реального времени
		int 1Ah
		mov al,dh		; секунды в формате BCD
		ror ax,1 		; циклический сдвиг вправо на 4 бита
		ror ax,1
		ror ax,1
		ror ax,1
		shr ah,1 		; логический сдвиг вправо на 4 бита
		shr ah,1
		shr ah,1
		shr ah,1
		or ax,'00'      ; в общем эта конструкция(220-228) выполняет корректировку полученного ASCII-кода секунд
		
		mov bx, POS_S1 	; указываем позицию
		call DELAY 		; производим задержку
		mov es:[bx], al ; производим отображение на позиции символа 
		
		mov bx, POS_S2 	; указываем позицию
		call DELAY 		; производим задержку
		mov es:[bx], ah ; производим отображение на позиции символа 
		
		pop dx          ; восстанавливаем регистры
		pop bx
		pop ax
		ret             ; возвращаемся в основную программу с восстановлением CS,IP
	Time_seconds endp
	
CODE ends           ; директива начала сегмента кодов
end START           ; начать выполнение кода