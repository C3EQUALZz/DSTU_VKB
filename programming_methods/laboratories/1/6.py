"""
Задача №869. Сортировка вагонов

К тупику со стороны пути 1 (см. рисунок) подъехал поезд.
Разрешается отцепить от поезда один или сразу несколько первых вагонов и завезти их в тупик (при желании,
можно даже завезти в тупик сразу весь поезд). После этого часть из этих вагонов вывезти в сторону пути 2.
После этого можно завезти в тупик еще несколько вагонов и снова часть оказавшихся вагонов вывезти в сторону пути 2.
И так далее (так, что каждый вагон может лишь один раз заехать с пути 1 в тупик, а затем один раз выехать из тупика на путь 2).
Заезжать в тупик с пути 2 или выезжать из тупика на путь 1 запрещается. Нельзя с пути 1 попасть на путь 2, не заезжая в тупик.

Известно, в каком порядке изначально идут вагоны поезда.
Требуется с помощью указанных операций сделать так, чтобы вагоны поезда шли по порядку (сначала первый, потом второй и т.д.,
считая от головы поезда, едущего по пути 2 в сторону от тупика). Напишите программу, определяющую, можно ли это сделать.
Входные данные

Вводится число N — количество вагонов в поезде (1≤N≤100).
Дальше идут номера вагонов в порядке от головы поезда, едущего по пути 1 в сторону тупика.
Вагоны пронумерованы натуральными числами от 1 до N, каждое из которых встречается ровно один раз.
Выходные данные

Если сделать так, чтобы вагоны шли в порядке от 1 до N, считая от головы поезда, когда поезд поедет по пути 2 из тупика,
можно, выведите сообщение YES, если это сделать нельзя, выведите NO.
"""

from collections import deque
from typing import Iterable, List


def can_sort_train(n: int, wagons: Iterable[int]) -> bool:
    """
    Задача заключается на работу со стеком. Здесь я использую два стека. Один для тупика, а второй для вывода (2 путь).
    Учитывайте, что номера вагонов идут с 1, а не 0.

    :param n: Количество вагонов в поезде.
    :param wagons: Список с номерами вагонов поездов.

    :returns: True, если можно поставить вагоны в правильном порядке, в ином случае False.
    """
    stack_deadlock: deque[int] = deque()
    stack_output: deque[int] = deque()

    for wagon in wagons:
        # Перемещаем вагоны из тупика на путь 2, если это возможно
        while stack_deadlock and stack_deadlock[-1] == len(stack_output) + 1:
            stack_output.append(stack_deadlock.pop())

        # Проверяем, можем ли сразу отправить вагон на путь 2
        if wagon == len(stack_output) + 1:
            stack_output.append(wagon)
        else:
            stack_deadlock.append(wagon)

    # Проверяем оставшиеся вагоны в тупике
    while stack_deadlock and stack_deadlock[-1] == len(stack_output) + 1:
        stack_output.append(stack_deadlock.pop())

    return len(stack_output) == n


def main() -> None:
    n: int = int(input())
    wagons: List[int] = list(map(int, input().split()))
    print("YES" if can_sort_train(n, wagons) else "NO")


if __name__ == "__main__":
    main()
