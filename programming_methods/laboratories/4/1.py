"""
Задача №1889. Два коня

На стандартной шахматной доске (8×8) живут 2 шахматных коня: Красный и Зелёный.
Обычно они беззаботно скачут по просторам доски, пощипывая шахматную травку, но сегодня особенный день: у Зелёного коня день рождения.
Зелёный конь решил отпраздновать это событие вместе с Красным.
Но для осуществления этого прекрасного плана им нужно оказаться на одной клетке.
Заметим, что Красный и Зёленый шахматные кони сильно отличаются от черного с белым: они ходят не по очереди,
а одновременно, и, если оказываются на одной клетке, никто никого не съедает.
Сколько ходов им потребуется, чтобы насладиться праздником?

Входные данные

Во входном файле содержатся координаты коней, записанные по стандартным шахматным правилам
(т. е. двумя символами — маленькая латинская буква (от a до h) и цифра (от 1 до 8),
задающие столбец и строку соответственно).

Выходные данные

Выходной файл должен содержать наименьшее необходимое количество ходов, либо −1, если кони не могут встретиться.
"""
from collections import deque
from itertools import product
from typing import Tuple, Generator, Any, Set


def get_moves(x: int, y: int) -> Generator[Tuple[int, int], Any, None]:
    """
    Генерирует все возможные ходы коня из заданной позиции на шахматной доске.

    :param x: Координата по оси X (столбец) коня.
    :param y: Координата по оси Y (строка) коня.
    :returns: Генератор, который выдает допустимые координаты (x, y) для каждого возможного хода коня,
    находящегося в пределах шахматной доски.
    """
    moves: Tuple[Tuple[int, int], ...] = (
        (x + 1, y + 2), (x + 2, y + 1), (x + 2, y - 1), (x + 1, y - 2),
        (x - 1, y - 2), (x - 2, y - 1), (x - 2, y + 1), (x - 1, y + 2)
    )
    yield from ((mx, my) for mx, my in moves if 0 <= mx <= 7 and 0 <= my <= 7)


def knights_meet(knight1: Tuple[int, int], knight2: Tuple[int, int]) -> int:
    """
    Определяет минимальное количество ходов, необходимых двум коням, чтобы встретиться на одной клетке.

    Здесь используется поиск в ширину (BFS) для нахождения кратчайшего пути, который позволяет
    двум коням одновременно перемещаться по шахматной доске. Каждый ход коня рассматривается как
    переход в новую клетку, и функция отслеживает все возможные позиции, которые могут быть
    достигнуты обоими конями.

    Алгоритм работает следующим образом:
    1. Инициализируется очередь, содержащая начальные позиции обоих коней и счетчик ходов, равный 0.
    2. В цикле, пока очередь не пуста:
        - Извлекаются текущие позиции обоих коней и количество сделанных ходов.
        - Если позиции коней совпадают, возвращается количество ходов.
        - Текущие позиции добавляются в множество посещенных.
        - Генерируются все возможные новые позиции для обоих коней с помощью функции get_moves.
        - Если новая пара позиций не была посещена, она добавляется в множество посещенных и помещается в очередь
         с увеличенным счетчиком ходов.
    3. Если очередь опустела и конь не встретился, возвращается -1.

    :param knight1: Координаты первого коня (x1, y1).
    :param knight2: Координаты второго коня (x2, y2).

    :returns: Минимальное количество ходов, необходимых для встречи коней, или -1, если они не могут встретиться.
    """
    visited: Set[Tuple[Tuple[int, int], Tuple[int, int]]] = set()
    queue: deque[Tuple[Tuple[int, int], Tuple[int, int], int]] = deque([(knight1, knight2, 0)])

    while queue:
        k1, k2, moves = queue.popleft()

        if k1 == k2:
            return moves

        visited.add((k1, k2))

        for move1, move2 in product(get_moves(k1[0], k1[1]), get_moves(k2[0], k2[1])):
            if (move1, move2) not in visited:
                visited.add((move1, move2))  # Добавляем в visited сразу
                queue.append((move1, move2, moves + 1))

    return -1


def main() -> None:
    knight1, knight2 = map(lambda k: (ord(k[0]) - ord('a'), int(k[1]) - 1), input().split())

    result: int = knights_meet(knight1, knight2)
    print(result)


if __name__ == "__main__":
    main()
