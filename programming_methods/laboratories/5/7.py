"""
Задача №3785. Задача коммивояжёра --- 2

На плоскости заданы координаты n (4≤n≤15) разных вершин.

Найти кратчайший замкнутый маршрут, начинающийся и заканчивающийся в 1-й вершине и посещающий все остальные вершины по одному разу.
Разрешается (если так оказывается выгодно) «проезжать через вершину, не останавливаясь» (см. пример 1).

Длина маршрута считается как сумма длин составляющих его рёбер, длины отдельных рёбер считаются согласно обычной
евклидовой метрике, как sqrt((xa-xb)^2 - (ya-yb)^2).

Входные данные

Первая строка содержит количество вершин n (4≤n≤15).
Каждая из следующих n строк содержит по два разделённых пробелом числа с плавающей точкой — x- и y-координаты соответствующей вершины.

Выходные данные

Первая строка должна содержать единственное число (с плавающей точкой) — найденную минимальную длину замкнутого тура.
Вторая строка должна содержать перестановку чисел 2, 3, ..., N — порядок, в котором надо посещать эти вершины.
Числа внутри второй строки должны разделяться одинарными пробелами.

Примечание

Задача с такими ограничениями, по идее, должна решаться хоть методом ветвей и границ, хоть динамическим программированием
по подмножествам. Но она, по идее, не должна решаться одними лишь отсечениями поиска с возвратом (backtracking),
не пытающегося оценивать возможный диапазон длины ещё не построенной части пути.
"""

import math
from collections import deque
from itertools import combinations
from typing import Dict, Iterable, List, Sequence, Tuple, cast


def reconstruct_path(
    memoization_table, bits: int, parent: int, n: int
) -> Iterable[int]:
    """
    Реконструирует оптимальный путь для задачи о путешествующем продавце (TSP)
    используя результаты, хранящиеся в таблице мемоизации.

    Эта функция работает в обратном направлении от конечной вершины к начальной,
    следуя родительским указателям, сохраненным во время решения задачи.

    Алгоритм:
    1. Начинаем с заданной `родительской` вершины и битовой маски `битов`, представляющей набор посещенных вершин.
    2. Для каждой вершины в пути (от последней до первой):
       - Добавляем текущую вершину к пути.
       - Обновляем `bits`, удалив текущую вершину.
       - Переходим к родительской вершине, хранящейся в таблице мемоизации.
    3. Возвращаем реконструированный путь в обратном порядке.


    :param memoization_table: Таблица, хранящая минимальную стоимость и родительскую вершину для каждого подмножества
            посещенных вершин и текущей вершины.
    :param bits: Битовая маска, представляющая набор посещенных вершин.
    :param parent: Текущая вершина, от которой нужно восстановить путь.
    :param n: Общее количество вершин в графе.
    :returns: Реконструированный путь как последовательность индексов вершин.
    """
    path: deque[int] = deque()

    for _ in range(n - 1):
        path.appendleft(parent)
        new_bits: int = bits & ~(1 << parent)
        _, parent = memoization_table[(bits, parent)]
        bits: int = new_bits

    return path


def tsp_dynamic_programming(
    points: Sequence[Tuple[float, float]],
) -> Tuple[float, Iterable[int]]:
    """
    Решает задачу о путешествующем продавце (TSP) с помощью динамического программирования с битовой маской.

    Цель TSP - найти кратчайший возможный маршрут, который посещает каждую вершину
    ровно один раз и возвращается в начальную вершину.

    Алгоритм:
    1. Строим матрицу расстояний для хранения попарных евклидовых расстояний между всеми вершинами.
    2. Используем таблицу мемоизации для хранения минимальной стоимости и родительской вершины для каждого подмножества
     посещенных вершин и текущей вершины.
    3. Итерируемся по всем подмножествам вершин и обновляем таблицу мемоизации с кратчайшим путем к каждому подмножеству.
    4. Завершаем тур, найдя кратчайший путь к начальной вершине.
    5. Реконструируем оптимальный путь с помощью функции `reconstruct_path`.

    :params points: Последовательность координат (x, y), представляющих вершины графа.
    :returns: Минимальная длина тура и оптимальный путь в виде последовательности индексов вершин, исключая начальную вершину.
    """
    n: int = len(points)
    dist_matrix: List[List[float]] = [
        [math.dist(points[i], points[j]) for j in range(n)] for i in range(n)
    ]

    # Таблица мемоизации, где ключами являются пары (набор посещенных вершин, текущая вершина)
    # Устанавливаем начальные значения, когда первая вершина уже посещена
    memoization_table: Dict[Tuple[int, int], Tuple[float, int]] = {
        (1 << k, k): (dist_matrix[0][k], 0) for k in range(1, n)
    }

    # Проходимся по вершинам
    for subset_size in range(2, n):
        for subset in combinations(range(1, n), subset_size):
            # Устанавливаем биты для всех вершин в подмножестве
            bits: int = sum(1 << bit for bit in subset)

            # Находим кратчайший путь к этому подмножеству, заканчивающийся в вершине k
            for k in subset:
                prev: int = bits & ~(1 << k)
                memoization_table[(bits, k)] = min(
                    (memoization_table[(prev, m)][0] + dist_matrix[m][k], m)
                    for m in subset
                    if m != 0 and m != k
                )

    # Мы возвращаемся к первой вершине, завершаем тур
    bits: int = (2**n - 1) - 1
    opt, parent = min(
        (memoization_table[(bits, k)][0] + dist_matrix[k][0], k) for k in range(1, n)
    )

    path = reconstruct_path(memoization_table, bits, parent, n)

    return opt, path


def main() -> None:
    n: int = int(input())
    points: List[Tuple[int, int]] = cast(
        List[Tuple[int, int]], [tuple(map(float, input().split())) for _ in range(n)]
    )
    min_length, min_path = tsp_dynamic_programming(points)
    print("{:.15E}".format(min_length))
    print(" ".join(map(lambda x: str(x + 1), min_path)))


if __name__ == "__main__":
    main()
