"""
Задача №2782. Следующий

Реализуйте структуру данных, которая поддерживает множество S целых чисел, с котором разрешается производить следующие операции:

add(i) — добавить в множество S число i (если он там уже есть, то множество не меняется);
next(i) — вывести минимальный элемент множества, не меньший i.
Если искомый элемент в структуре отсутствует, необходимо вывести -1.

Входные данные

Исходно множество S пусто.
Первая строка входного файла содержит n — количество операций (1≤n≤300000).
Следующие n строк содержат операции.
Каждая операция имеет вид либо «+ i», либо «? i». Операция «? i» задает запрос next(i).

Если операция «+ i» идет во входном файле в начале или после другой операции «+», то она задает операцию add(i).
Если же она идет после запроса «?», и результат этого запроса был y, то выполняется операция add((i+y)mod10^9).

Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 10^9.

Выходные данные

Для каждого запроса выведите одно число — ответ на запрос.

НЕ УСПЕВАЕТ ПО СКОРОСТИ ИЗ-ЗА PYTHON. РЕШЕНИЕ НА 100 БАЛЛОВ C++
"""

import bisect
import math
from typing import Generic, List, TypeVar, Union

T = TypeVar("T")


class SortedList(Generic[T]):
    def __init__(self) -> None:
        """
        Класс, представляющий отсортированный список с поддержкой операций добавления
        и поиска минимального элемента, который больше или равен заданному значению.

        Атрибуты:
        list: Сортированный список элементов.
        last_query: Результат последнего запроса next, используется для корректировки
                          следующей операции add.
        """
        self.list: List[T] = []
        self.last_query: int = -1

    def add(self, x: T) -> None:
        """
        Добавляет элемент x в список. Если после предыдущего запроса next был результат,
        то значение x модифицируется с учётом этого результата.

        Алгоритм:
            1. Если был выполнен предыдущий запрос, модифицируем значение x
            2. Находим позицию, где должно быть вставлено новое значение.
            3. Если такого элемента нет, вставляем его в нужное место
            4. Сбрасываем переменную last_query после добавления

        :param x: Элемент, который нужно добавить в список.
        :return: Ничего не возвращает
        """
        if self.last_query != -1:
            x = (x + self.last_query) % int(math.pow(10, 9))

        position: int = bisect.bisect_left(self.list, x)

        if position == len(self.list) or self.list[position] != x:
            bisect.insort(self.list, x)

        self.last_query = -1

    def next(self, x: T) -> Union[T, int]:
        """
        Находит минимальный элемент в списке, который больше или равен x.

        Алгоритм:
            1. Находим позицию первого элемента, который не меньше x.
            2. Если такой элемент найден, возвращаем его.
            3. Если элемент не найден, сбрасываем last_query и возвращаем -1

        :param x: Число, с которым нужно сравнивать элементы списка.
        :returns: Минимальный элемент, который больше или равен x. В ином случае, -1, если такого элемента не существует.
        """
        pos: int = bisect.bisect_left(self.list, x)

        if pos < len(self.list):
            self.last_query = self.list[pos]
            return self.last_query

        self.last_query = -1
        return -1


def main() -> None:
    n: int = int(input())
    sorted_list: SortedList[int] = SortedList()

    for _ in range(n):
        operation, x = input().split()
        x = int(x)
        if operation == "+":
            sorted_list.add(x)
        elif operation == "?":
            print(sorted_list.next(x))


if __name__ == "__main__":
    main()
