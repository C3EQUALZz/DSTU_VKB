"""
Задача №1750. Подпалиндромы

Строка называется палиндромом, если она читается одинаково как слева направо, так и справа налево.
Например, строки abba, ata являются палиндромами.

Дана строчка. Ее подстрокой называется некоторая непустая последовательность подряд идущих символов.
Напишите программу, которая определит, сколько подстрок данной строки является палиндромами.

Входные данные

Вводится одна строка, состоящая из маленьких латинских букв. Длина строки не превышает 100000 символов.

Выходные данные

Выведите одно число — количество подстрок данной строки, являющихся палиндромами
"""

from array import ArrayType, array


def find_palindromes(s: str) -> int:
    """
    Для поиска палиндромов используется метод Манакера, который позволяет эффективно
    находить все палиндромы в строке за линейное время.

    Шаги алгоритма:

    1. Преобразуем исходную строку `s` в строку с разделителями и сторожевыми символами:
       - Строка преобразуется в новую строку `transformed_string`, добавляя специальные символы
         (например, `@#` в начале и `#$` в конце) и разделяя каждый символ строки на отдельные элементы
         с помощью символа `#`. Это позволяет упростить поиск палиндромов как с четной, так и с нечетной длиной.

    2. Инициализируем массив `palindrome_lengths`, где каждый элемент хранит максимальный радиус палиндрома,
       который можно расширить, начиная с соответствующей позиции в преобразованной строке.

    3. Используем два указателя:
       - `center` — центр текущего палиндрома.
       - `right_boundary` — правая граница этого палиндрома.

    4. Для каждой позиции `i` в преобразованной строке:
       - Если позиция находится в пределах текущего палиндрома (т.е. `i < right_boundary`),
         то для этой позиции пытаемся взять максимальную длину палиндрома, используя зеркальную симметрию.
       - Далее расширяем палиндром вокруг центра `i`, сравнивая символы слева и справа от него.
       - Если найден новый более длинный палиндром, обновляем `center` и `right_boundary`.

    5. Подсчитываем количество палиндромных подстрок:
       - Для каждого значения в массиве `palindrome_lengths` вычисляем количество палиндромных подстрок,
         которые можно извлечь из палиндрома с радиусом, равным значению в массиве. Это делается с помощью формулы
          `(length + 1) // 2`.

    6. Возвращаем сумму всех этих значений как итоговое количество палиндромных подстрок.

    :param s: Входная строка из условия.
    :returns: Количество подстрок данной строки, которые являются палиндромами.
    """
    # Преобразуем строку для работы с палиндромами
    transformed_string: str = "@#" + "#".join(s) + "#$"
    palindrome_lengths: ArrayType[int] = array("i", [0] * len(transformed_string))
    center: int = 0
    right_boundary: int = 0

    for i in range(1, len(transformed_string) - 1):
        if i < right_boundary:
            palindrome_lengths[i] = min(
                right_boundary - i, palindrome_lengths[2 * center - i]
            )

        # Расширяем палиндром вокруг центра i
        while (
            transformed_string[i + palindrome_lengths[i] + 1]
            == transformed_string[i - palindrome_lengths[i] - 1]
        ):
            palindrome_lengths[i] += 1

        # Обновляем центр и правую границу, если нашли более длинный палиндром
        if i + palindrome_lengths[i] > right_boundary:
            center, right_boundary = i, i + palindrome_lengths[i]

    # Считаем количество палиндромных подстрок
    return sum((length + 1) // 2 for length in palindrome_lengths)


def main() -> None:
    input_string: str = input()
    print(find_palindromes(input_string))


if __name__ == "__main__":
    main()
